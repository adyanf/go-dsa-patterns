package fastslowpointers

/*
The Fast & Slow Pointers pattern, also known as the Hare & Tortoise algorithm,
is a common technique used to solve problems involving linked lists, arrays, or
other sequences where you need to detect cycles or find specific positions.

How it works:
The core idea is to use two pointers that traverse the data structure at
different speeds. A "slow" pointer moves one step at a time, while a "fast"
pointer moves two (or more) steps at a time.

Common Use Cases:
1. Cycle Detection in a Linked List:
   - If a linked list has a cycle, the fast pointer will eventually catch up
     to and meet the slow pointer.
   - If the list has no cycle, the fast pointer will reach the end of the list first.

2. Finding the Middle of a Linked List:
   - When the fast pointer reaches the end of the list, the slow pointer will be
     at the middle.

3. Finding the Start of a Cycle:
   - Once the pointers meet, reset one pointer to the head of the list and move
     both pointers one step at a time. They will meet at the start of the cycle.

4. Finding a Happy Number:
   - The sequence of numbers generated by squaring digits and summing them can be
     treated like a linked list. If a number is not happy, it will eventually
     enter a cycle (which includes the number 1 for happy numbers).

This pattern is efficient because it typically solves these problems in O(n)
time and O(1) space.
*/

// FindDuplicate finds and returns the duplicate number present in nums.
func FindDuplicate(nums []int) int {
	// start both slow and fast pointer from the value of 0 index
	slow, fast := nums[0], nums[0]

	// iterate until the slow and fast pointers meets
	// in each iteration, slow pointer move one step forward and fast pointer move two step forward
	// the pointers will meets each other in intersection point if the nums is cyclic (have duplicate number)
	// in general, intersection point is not the entry point of the cycle
	for {
		slow = nums[slow]
		fast = nums[nums[fast]]
		if slow == fast {
			break
		}
	}

	// reset the slow pointer to the value of 0 index
	slow = nums[0]
	// iterate until the slow and fast pointers meets
	// in each iteration, move slow and fast pointers one step forward
	// the pointers will meets each other in entry point of the cycle which is the duplicate number
	for slow != fast {
		slow = nums[slow]
		fast = nums[fast]
	}

	return slow
}
