package fastslowpointers

/*
The Fast & Slow Pointers pattern, also known as the Hare & Tortoise algorithm,
is a common technique used to solve problems involving linked lists, arrays, or
other sequences where you need to detect cycles or find specific positions.

How it works:
The core idea is to use two pointers that traverse the data structure at
different speeds. A "slow" pointer moves one step at a time, while a "fast"
pointer moves two (or more) steps at a time.

Common Use Cases:
1. Cycle Detection in a Linked List:
   - If a linked list has a cycle, the fast pointer will eventually catch up
     to and meet the slow pointer.
   - If the list has no cycle, the fast pointer will reach the end of the list first.

2. Finding the Middle of a Linked List:
   - When the fast pointer reaches the end of the list, the slow pointer will be
     at the middle.

3. Finding the Start of a Cycle:
   - Once the pointers meet, reset one pointer to the head of the list and move
     both pointers one step at a time. They will meet at the start of the cycle.

4. Finding a Happy Number:
   - The sequence of numbers generated by squaring digits and summing them can be
     treated like a linked list. If a number is not happy, it will eventually
     enter a cycle (which includes the number 1 for happy numbers).

This pattern is efficient because it typically solves these problems in O(n)
time and O(1) space.
*/

// FindDuplicate finds and returns the duplicate number present in nums.
func FindDuplicate(nums []int) int {
	// start both slow and fast pointer from the value of 0 index
	slow, fast := nums[0], nums[0]

	// iterate until the slow and fast pointers meets
	// in each iteration, slow pointer move one step forward and fast pointer move two step forward
	// the pointers will meets each other in intersection point if the nums is cyclic (have duplicate number)
	// in general, intersection point is not the entry point of the cycle
	for {
		slow = nums[slow]
		fast = nums[nums[fast]]
		if slow == fast {
			break
		}
	}

	// reset the slow pointer to the value of 0 index
	slow = nums[0]
	// iterate until the slow and fast pointers meets
	// in each iteration, move slow and fast pointers one step forward
	// the pointers will meets each other in entry point of the cycle which is the duplicate number
	for slow != fast {
		slow = nums[slow]
		fast = nums[fast]
	}

	return slow
}

// CircularArrayLoop returns true if such a cycle exists in the list or false otherwise.
// A cycle in this list means:
// 1. You keep moving according to the numbers, and you end up repeating a sequence of indexes.
// 2. All numbers in the cycle have the same sign (either all positive or all negative).
// 3. The cycle length is greater than 1 (it involves at least two indexes).
func CircularArrayLoop(nums []int) bool {
	size := len(nums)

	// check the circular array loop from each element as first pointer
	for i := range nums {
		slow, fast := i, i
		forward := nums[i] > 0

		for {
			// use fast and slow pointer move to next step for each pointer
			// slow pointer move one step at a time
			// fast pointer move two steps at a time
			// for each step check if the invalid cycle is detected
			// if detected then break the for loop and continue starting the next element
			slow = circularArrayLoopNextStep(slow, nums[slow], size)
			if isInvalidCycle(nums, forward, slow) {
				break
			}
			fast = circularArrayLoopNextStep(fast, nums[fast], size)
			if isInvalidCycle(nums, forward, fast) {
				break
			}
			fast = circularArrayLoopNextStep(fast, nums[fast], size)
			if isInvalidCycle(nums, forward, fast) {
				break
			}

			// if no invalid cycle detected and fast and slow pointers point to the same elements then we found valid circular array loop
			if slow == fast {
				return true
			}
		}
	}

	// if after iterate all elements as first pointer and we still didn't find the circular array loop then return false
	return false
}

// circularArrayLoopNextStep returns the next index based on current index, move, and array size of circular array loop
func circularArrayLoopNextStep(current int, move int, size int) int {
	result := (current + move) % size
	if result < 0 {
		result += size
	}
	return result
}

// isInvalidCycle returns true if invalid cycle detected
// invalid cycle is when the cycle contains different sign of movement
// or when the cycle length is equal to 1
func isInvalidCycle(nums []int, prevDirection bool, current int) bool {
	currentDirection := nums[current] >= 0
	if prevDirection != currentDirection || nums[current]%len(nums) == 0 {
		return true
	}
	return false
}
